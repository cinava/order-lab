<?php

namespace Oleg\OrderformBundle\Repository;

/**
 * AccessionRepository
 * This class was generated by the Doctrine ORM.
 * Add your own custom repository methods below.
 */
class AccessionRepository extends ArrayFieldAbstractRepository {


    public function processDuplicationKeyField( $accession, $orderinfo ) {

        if( count($orderinfo->getDataquality()) == 0 ) {
            return $accession;
        }

        //echo "process Accession: ".$accession;
        //$this->printTree( $accession->getParent()->getParent() );

        //process data quality
        $currentDataquality = null;
        foreach( $orderinfo->getDataquality() as $dataquality) {

            $accessionConflict = false;
            $patientConflict = false;

            //check if this dataquality's patient is corresponds to accession patient
            $mrn = $dataquality->getMrn();
            $mrntype = $dataquality->getMrntype()->getId();
            $validMrn = $accession->getParent()->getParent()->obtainValidKeyfield();
            $accmrn = $validMrn->getField();
            $accmrntype = $validMrn->getMrntype()->getId();
            //echo "compare patient: ".$mrn ."==". $accmrn ."&&". $mrntype ."==". $accmrntype."<br>";
            if( $mrn == $accmrn && $mrntype == $accmrntype ) {
                $patientConflict = true;
                //break;
            }

            $conflictAccessionNum = $dataquality->getAccession()."";
            $currentAccessionNum = $accession->obtainValidKeyfield();
            //echo $currentAccessionNum."?=".$conflictAccessionNum.", newAccession=".$dataquality->getNewaccession()."<br>";
            if( $currentAccessionNum == $conflictAccessionNum ) { //only for match accessions and if this accession was not processed yet
                if( !$dataquality->getNewaccession() ) {
                    $accessionConflict = true;
                }
            }

            if( $accessionConflict && $patientConflict ) {
                $currentDataquality = $dataquality;
                break;
            }
        }

//        if( !$accessionConflict || !$patientConflict ) {
        if( !$currentDataquality ) {
            //echo "#####this is not conflict accession => return !!!!!! <br>";
            return $accession;
        }

        //Now we know that this accession has MRN conflict

        //$entity = $em->getRepository('OlegOrderformBundle:Accession')->createElement(null,$user,"Accession","accession");
        //1) take care of mrn-accession conflict: replace accession# with ACCESSIONNONPROVIDED:
        $accession->setId(null); //make sure to generate a new accession
        $accession->setStatusAllKeyfield(self::STATUS_INVALID);
        $nextKey = $this->getNextNonProvided($accession,null,$orderinfo);
        $accession->createKeyField();

        //set new accession number to dataquality
        $currentDataquality->setNewaccession($nextKey);

        //we should have only one key field !!!
        $key = $accession->obtainValidKeyField();
        $key->setField($nextKey);
        $key->setStatus(self::STATUS_VALID);
        $key->setProvider($orderinfo->getProvider()->first());

        //save in DB, so the next conflict Accession will be generated correctly from DB; other way is to loop for newaccessions in this orderinfo's dataquality
//        $em = $this->_em;
//        $em->persist($key);
//        $em->flush();

//        echo "<br>-----------------Original Accession:<br>";
//        $this->printTree( $accession );
//        echo "--------------------------<br>";
        //echo "finish process Accession: ".$accession."<br>";

        //TODO: remove ID from all children?

        return $accession;

    }

    //filter out duplicate virtual (in form, not in DB) accessions from specimen
    public function removeDuplicateEntities( $procedure ) {

        $accessions = $procedure->getAccession();
        
        if( count($accessions) == 1 ) {
            return $procedure;
        }

        $accessionNums = array();

        foreach( $accessions as $accession ) {

            //echo "accession=".$accession."<br>";
            $accNum = $accession->getAccession();

            if( count($accessionNums) == 0 || !in_array($accNum, $accessionNums) ) {
                $accessionNums[] = $accNum;
                //persist the rest of entities, because they will be added to DB.
                $em = $this->_em;
                $em->persist($accession);
            } else {
                $procedure->removeAccession($accession);
            }

        }

        return $procedure;
    }

}
?>
