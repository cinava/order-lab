<?php

namespace Oleg\OrderformBundle\Repository;

//use Doctrine\ORM\EntityRepository;
//use Oleg\OrderformBundle\Entity\Accession;

/**
 * AccessionRepository
 * This class was generated by the Doctrine ORM.
 * Add your own custom repository methods below.
 */
class AccessionRepository extends ArrayFieldAbstractRepository {

    //TODO: we cannot attach an Accession to multiple different Patients!
    public function processDuplicationKeyField( $accession, $orderinfo ) {

        if( count($orderinfo->getDataquality()) == 0 ) {
            return $accession;
        }

        $em = $this->_em;

        echo "process Accession: ".$accession;
        $this->printTree( $accession->getParent()->getParent() );

        //process data quality
        $accessionConflict = false;
        foreach( $orderinfo->getDataquality() as $dataquality) {
            $conflictAccessionNum = $dataquality->getAccession()."";
            $currentAccessionNum = $accession->getAccession()->first()->getField()."";
            echo $currentAccessionNum."?=".$conflictAccessionNum."<br>";
            if( $currentAccessionNum == $conflictAccessionNum ) {
                $accessionConflict = true;
                break;
            }
        }

        if( !$accessionConflict ) {
            return $accession;
        }

        //Now we know that this accession has MRN conflict

        //take care of mrn-accession conflict: create new patient with MRNNONPROVIDED:
        //1) if there is a conflict then accession is exists in DB

        $accessionFound = $em->getRepository('OlegOrderformBundle:Accession')->findOneByIdJoinedToField($dataquality->getAccession(),"Accession","accession",true, true);
        $procedureFound = $accessionFound->getParent();

        echo "<br>-----------------Original Accession:<br>";
        $this->printTree( $accession );
        echo "--------------------------<br>";

        //1a) copy children from original accession to a found one
        foreach( $accession->getChildren() as $child ) {
            echo $child;
            $accessionFound->addChildren( $child );
            echo $child;
        }

        echo "<br>-------------------------accessionFound:<br>";
        $this->printTree( $accessionFound );
        echo "--------------------------<br>";
        echo "blockCount=".count($accessionFound->getPart()->first()->getBlock())."<br>";


        //2) remove conflicting accession from existing patient
        echo "accession found: remove procedure<br>";
        $procedure = $accession->getParent();
        $patient = $procedure->getParent();
        $patient->removeProcedure($procedure);

        if( !$procedureFound ) {
            throw new \Exception( 'Corresponding Procedure-Accession was not found' );
        }

        //3)create a new patient
        $user = $orderinfo->getProvider()->first();
        $extra = array();
        $extra["mrntype"] = $dataquality->getMrntype()->getId();
        $newPatient = $em->getRepository('OlegOrderformBundle:Patient')->createElement(null,$user,"Patient","mrn",null,null,$extra,false);

        //4) attach found accession to a new created patient
        $newPatient->addChildren($procedureFound);

        //4a) attach original (form procedure) to a new created patient

        //5) add this new created patient to this order
        $orderinfo->addPatient($newPatient);


        return $accessionFound;
    }

    //filter out duplicate virtual (in form, not in DB) accessions from specimen
    public function removeDuplicateEntities( $procedure ) {

        $accessions = $procedure->getAccession();
        
        if( count($accessions) == 1 ) {
            return $procedure;
        }

        $accessionNums = array();

        foreach( $accessions as $accession ) {

            //echo "accession=".$accession."<br>";
            $accNum = $accession->getAccession();

            if( count($accessionNums) == 0 || !in_array($accNum, $accessionNums) ) {
                $accessionNums[] = $accNum;
                //persist the rest of entities, because they will be added to DB.
                $em = $this->_em;
                $em->persist($accession);
            } else {
                $procedure->removeAccession($accession);
            }

        }

        return $procedure;
    }

}
?>
