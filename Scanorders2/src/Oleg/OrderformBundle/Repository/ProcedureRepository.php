<?php

namespace Oleg\OrderformBundle\Repository;

//use Doctrine\ORM\EntityRepository;

/**
 * ProcedureRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ProcedureRepository extends ArrayFieldAbstractRepository
{

    public function processEntity( $entity, $orderinfo ) {

        $em = $this->_em;

        //find accession
        $accessions = $entity->getAccession();

        if( count($accessions) > 1 ) {
            throw new \Exception( 'More than one Accession in the Procedure. Number of accession=' . count($accessions) );
        }

        //we should have only one Accession in the Procedure, because Procedure-Accession is considered as one object for now
        $accession = $accessions->first();

        //redirect to accession repository (skip procedure, because one procedure is linked to one accession)
        $accessionProcessed = $em->getRepository('OlegOrderformBundle:Accession')->processEntity( $accession, $orderinfo );
        //echo "exit Accession process<br>";

        //process Procedure
        $procedureProcessed = $accessionProcessed->getProcedure();

        if( !$procedureProcessed ) {
            //$procedureProcessed = $em->getRepository('OlegOrderformBundle:Procedure')->createElement(null,$orderinfo->getProvider()->first(),"Procedure","encounter",$entity->getParent(),null,null);
            //$procedureProcessed->addChildren($accessionProcessed);

            //$procedureProcessed->addName($entity->getName());
            $entity->removeChildren($accession);
            $entity->addChildren($accessionProcessed);

            $procedureProcessed = $entity;

            //echo "No procedures <br>";
        }

        //echo "encounter=".$procedureProcessed->getEncounter()->first().", Name=".$procedureProcessed->getName()->first()."<br>";
        //echo "before process:".$entity;

        //process parent procedure processEntity method (setResult method is provided here)
        $procedureProcessed = parent::processEntity( $procedureProcessed, $orderinfo );

        //Exception for procedure: Final Step CopyFields
        $procedureProcessed = $this->processFieldArrays($procedureProcessed,$orderinfo,$entity);

        //echo "after process:".$entity;

        return $procedureProcessed;

    }

    public function setResult( $procedure, $orderinfo=null, $original=null ) {

        //set status 'valid'
        $procedure->setStatus(self::STATUS_VALID);

        //CopyFields
        $procedure = $this->processFieldArrays($procedure,$orderinfo,$original);

        if( count($procedure->getAccession()) > 1 ) {
            throw new \Exception( 'More than one Accession in the Procedure. Number of accession=' . count($procedure->getAccession()) );
        }

        //link orderinfo with accession
        $accession = $procedure->getAccession()->first();

        //we have to process accession again because the original accession's methods exexutes by the end of orderinfo process
        $accession = $this->processFieldArrays($accession,$orderinfo);
        $em = $this->_em;
        $accession = $em->getRepository('OlegOrderformBundle:Accession')->changeKeytype($accession);

        //add accession and procedure to orderinfo
//        $attached = $this->attachToOrderinfo($accession,$orderinfo);
//        if( $attached > 0 ) {
//            //echo "add procedure ".$attached."<br>";
//            //$this->attachToOrderinfo($procedure,$orderinfo);
//            $orderinfo->addProcedure($procedure);
//        } else {
//            //echo "do not add procedure:".$procedure;
//        }

        //echo "acc children=".count();

        if( !$procedure->getId() || $procedure->getId() == "" ) {
            //echo "persist Procedure<br>";
            $em->persist($procedure);
        } else {
            //echo "merge Procedure<br>";
            //$em->merge($entity);
        }

        return $procedure;
    }

    //exception for procedure: procedure is linked to a single accession => check if accession is already existed in DB, if existed => don't create procedure, but use existing procedure
    public function findUniqueByKey( $entity ) {

        //echo "findUniqueByKey: Procedure: ".$entity;

        if( count($entity->getChildren()) != 1 ) {
            throw new \Exception( 'This entity must have only one child. Number of children=' . count($entity->getChildren()) );
        }

//        $accession = $entity->getChildren()->first();
//        $class = new \ReflectionClass($accession);
//        $className = $class->getShortName();
//        //echo "findUniqueByKey: Procedure: className=".$className."<br>";

        $em = $this->_em;
        $foundAccession = $em->getRepository('OlegOrderformBundle:Accession')->findUniqueByKey( $entity->getChildren()->first() );    //,"Accession","accession");

        if( $foundAccession ) {
            //echo "This entity alsready exists in DB ".$foundAccession."<br>";
            //get existing procedure
            return $foundAccession->getParent(); //Accession->getProcedure => procedure

        } else {
            return null;
        }
    }


    //TODO: remove MRN check (check procedure only by Accession number)
    //filter out duplicate virtual (in form, not in DB) procedures from provided patient
    public function removeDuplicateEntities( $patient ) {

        $procedures = $patient->getProcedure();
        //echo "procedure count=".count($procedures)."<br>";
        if( count($procedures) <= 1 ) {
            //echo "only 0 or 1 procedure found=".count($procedures)."<br>";
            //exit();
            return $patient;
        }

        //echo "procedure count1=".count($patient->getProcedure())."<br>";

        $count = 0;
        foreach( $procedures as $procedure ) {

            //echo $procedure;

            //1) check if accession is given
            $accessions = $procedure->getAccession();
            if( $accessions == null || count($accessions) == 0 ) {
                //can't check for duplicate without accession => don't remove this procedure => keep this procedure as unique
                //echo "cant check for duplicate without accession <br>";
                continue;
            }

            //2) check if at least one accession belongs to another (second) procedure, then we can potentially use this first procedure and remove the second one.
            $accession_found = null;
            foreach( $accessions as $accession ) {

                //if accession exists then return procedure for this accession; otherwise, create a new
                if( ($count+1) < count($procedures) ) { //make sure index exists and no need to check the last procedure

                    //if( in_array($accession, $procedures[$count+1]->getAccession() ) ) {
                    foreach( $procedures[$count+1]->getAccession() as $accNext ) {
                        //echo "compare: ".$accession->getAccession() ."?". $accNext->getAccession()."<br>";
                        if( $accession->getAccession() == $accNext->getAccession() ) {
                            $accession_found = $accession;
                            break;
                        }
                    }
                }
            }

            $em = $this->_em;

            if( $accession_found == null || $accession_found->getProcedure() == null ) {
                //don't remove
                //echo "no common accessions found <br>";
                //persist the rest of procedures, because they will be added to DB.
                $em->persist($procedure);
            } else {
                //now check if the next procedure (potentially to be removed) has the same MRN, don't check if MRN = "" => new dummy mrn will be generated
                if( $procedure->getPatient()->getMrn() != null && $procedure->getPatient()->getMrn() != "" ) {
                    if( $procedures[$count+1]->getPatient()->getMrn() == $procedure->getPatient()->getMrn() ) {
                        $patient->removeProcedure( $procedures[$count+1] );
                        //echo "remove procedure=".$procedure[$count+1];
                    } else {
                        $em->persist($procedure);
                    }
                }
            }

            $count++;
        }

        //echo "procedure count2=".count($patient->getprocedure())."<br>";
        //exit();

        return $patient;
    }

}
