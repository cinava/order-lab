<?php

namespace Oleg\OrderformBundle\Repository;


/**
 * ProcedureRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ProcedureRepository extends ArrayFieldAbstractRepository
{

    //exception for procedure: procedure is linked to a single accession => check if accession is already existed in DB, if existed => don't create procedure, but use existing procedure
    public function findUniqueByKey( $entity ) {

        //echo "find Unique By Key: Procedure: ".$entity;

        if( count($entity->getChildren()) != 1 ) {
            throw new \Exception( 'This entity must have only one child. Number of children=' . count($entity->getChildren()) );
        }

        $em = $this->_em;
        $foundAccession = $em->getRepository('OlegOrderformBundle:Accession')->findUniqueByKey( $entity->getChildren()->first() );    //,"Accession","accession");

        if( $foundAccession ) {
            //echo "This entity alsready exists in DB ".$foundAccession."<br>";
            //get existing procedure
            return $foundAccession->getParent(); //Accession->getProcedure => procedure

        } else {
            return null;
        }
    }

    //make sure procedure type is set to "Auto-generated Procedure Number"
    public function changeKeytype($entity) {

        $key = $entity->obtainValidKeyField();

        if( !$key->getKeytype() || $key->getKeytype() == "" ) {
            //throw new \Exception( 'Procedure does not have a valid keytype. keytype=' . $key->getKeytype() );
            $em = $this->_em;
            $newkeytypeEntity = $em->getRepository('OlegOrderformBundle:ProcedureType')->findOneByName("Auto-generated Procedure Number");
            $key->setKeytype($newkeytypeEntity);
        }

        if( $key == "" || $key->getField() != "Auto-generated Procedure Number" ) {
            $em = $this->_em;
            $newkeytypeEntity = $em->getRepository('OlegOrderformBundle:ProcedureType')->findOneByName("Auto-generated Procedure Number");
            $key->setKeytype($newkeytypeEntity);
        }

        //strip zeros and record original
        $originalKey = $key->getField();
        $key->setOriginal($originalKey);
        $stripedKey = ltrim($originalKey,'0');
        $key->setField($stripedKey);

        return $entity;
    }

    //replace child if duplicated
    //$parent: encounter
    //procedure has only one accession
    public function replaceDuplicateEntities( $parent, $orderinfo ) {
        //echo "Procedure replace duplicates:".$parent;
        return $parent;
    }



    //find similar procedure in encounter.
    //However, procedure is identified by accession number
    //$parent: encounter
    //$newChild: accession
    //find similar child and return the first one
    //return false if no similar children are found
    public function findSimilarChild($parent,$newChild) {

        exit('This function is not used. '.$newChild);

        //echo "Procedure: find similar Child to: ".$newChild." <br>";

        $children = $parent->getChildren();

        //echo "<br>";
        //echo $newChild;
        //echo "newChild key=".$newChild->obtainValidKeyfield()."<br>";
        if( $newChild->obtainValidKeyfield()."" == "" ) {   //no name is provided, so can't compare => does not exist
            //echo "false: no name <br>";
            return false;
        }

        if( !$children || count($children) == 0 ) { //no children => does not exist
            //echo "false: no children <br>";
            return false;
        }

        foreach( $children as $child ) {
            //echo $child;

            if( count($child->getAccession()) != 1 ) {
                throw new \Exception( 'This entity must have only one child. Number of children=' . count($child->getAccession()) );
            }

            if( $child->getAccession()->first() === $newChild ) {
                //echo "the same child: continue<br>";
                return false;
            }

            if( $this->entityEqualByComplexKey($child->getAccession()->first(), $newChild) ) {
                //echo "MATCH!: ".$child." <br>";
                return $child;
            } else {
                //echo "NO MATCH! <br>";
            }

        }//foreach

        return false;
    }


    //process conflict if exists for accession number. Replace conflicting accession number by a new generated number.
    //This function redirects to the same overrided function by Accession Repository
    public function processDuplicationKeyField( $procedure, $orderinfo ) {

        $accessions = $procedure->getChildren();

        if( count($accessions) != 1 ) {
            throw new \Exception( 'Procedure entity must have only one Accession. Number of Accession found is ' . count($accessions) );
        }

        $accession = $accessions->first();

        $procedure->removeChildren($accession);

        //process conflict if exists for accession number. Replace conflicting accession number by a new generated number.
        $accession = $this->_em->getRepository('OlegOrderformBundle:Accession')->processDuplicationKeyField($accession,$orderinfo);

        $procedure->addChildren($accession);

        return $procedure;
    }

}
