<?php

namespace Oleg\OrderformBundle\Repository;

//use Doctrine\ORM\EntityRepository;

/**
 * ProcedureRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ProcedureRepository extends ArrayFieldAbstractRepository
{

    //$entity is procedure
    public function processEntity( $entity, $orderinfo ) {

        if( !$entity ) {
            throw new \Exception('Provided entity for processing is null');
            //return $entity;
        }

        $em = $this->_em;
        $class = new \ReflectionClass($entity);
        $className = $class->getShortName();

        //echo "<br>processEntity className (overwrited by procedure)=".$className.", keyFieldName=".$entity->obtainKeyFieldName()."<br>";
        //echo $entity;

        //check and remove duplication objects such as two Part 'A'.
        $entity = $em->getRepository('OlegOrderformBundle:'.$className)->replaceDuplicateEntities( $entity, $orderinfo );

        //process conflict if exists for accession number. Replace conflicting accession number by a new generated number.
        $entity = $em->getRepository('OlegOrderformBundle:'.$className)->processDuplicationKeyField($entity,$orderinfo);

        $keys = $entity->obtainAllKeyfield();

        //echo "count keys=".count($keys)."<br>";
        //echo "key=".$keys->first()."<br>";

        if( count($keys) == 0 ) {
            //$entity->createKeyField();  //this should never execute in normal situation
            throw new \Exception( 'Key field does not exists for '.$className );
        } elseif( count($keys) > 1 ) {
            //throw new \Exception( 'This Object ' . $className . ' must have only one key field. Number of key field=' . count($keys) );
            //echo( 'This Object ' . $className . ' should have only one key field. Number of key field=' . count($keys) );

        }

        $key = $entity->obtainValidKeyField();
        //echo "valid key=".$key.", status=".$key->getStatus()."<br>";

        //change keytype from Existing Auto-generated MRN to Existing Auto-generated MRN
        $entity = $this->changeKeytype($entity);

        if( $orderinfo->getStatus() == 'Amended' ) {
            $found = null;
        } else {
            //this is a main function to check uniqueness
            $found = $this->findUniqueByKey($entity);   //$found - procedure in DB
        }

        if( $found ) {
            //echo "Case 2: object exists in DB (eneterd key is for existing object): Copy Children, Copy Fields <br>";
            //CopyChildren: copy form's object children to the found one.
            foreach( $entity->getChildren() as $child ) {
                //echo "adding: ".$child."<br>";
                $found->addChildren( $child );
            }
            return $this->setResult($found, $orderinfo, $entity);

            //$entity->setId( $found->getId() );
            //return $this->setResult($entity, $orderinfo);

        } else
        if( $key == "" ) {
            //echo "Case 1: Empty form object (all fields are empty): generate next available key and assign to this object <br>";

            $nextKey = $this->getNextNonProvided($entity,null,$orderinfo);  //"NO".strtoupper($fieldName)."PROVIDED", $className, $fieldName);

            //we should have only one key field !!!
            $key->setField($nextKey);
            $key->setStatus(self::STATUS_VALID);
            $key->setProvider($orderinfo->getProvider()->first());
        }
        else {
            //echo "Case 3: object does not exist in DB (new key is eneterd) <br>";
            throw new \Exception('Invalid logic for Procedure, key='.$key);
        }



//        if( $key == ""  ) { //$key == "" is the same as $key->getName().""
//            echo "Case 1: Empty form object (all fields are empty): generate next available key and assign to this object <br>";
//
//            //additional comparison by accession
//
//            $nextKey = $this->getNextNonProvided($entity,null,$orderinfo);  //"NO".strtoupper($fieldName)."PROVIDED", $className, $fieldName);
//
//            //we should have only one key field !!!
//            $key->setField($nextKey);
//            $key->setStatus(self::STATUS_VALID);
//            $key->setProvider($orderinfo->getProvider()->first());
//
//        } else {
//
//            if( $orderinfo->getStatus() == 'Amended' ) {
//                $found = null;
//            } else {
//                //this is a main function to check uniqueness
//                $found = $this->findUniqueByKey($entity);   //$found - procedure in DB
//            }
//
//
//            if( $found ) {
//                echo "Case 2: object exists in DB (eneterd key is for existing object): Copy Children, Copy Fields <br>";
//                //CopyChildren: copy form's object children to the found one.
//                foreach( $entity->getChildren() as $child ) {
//                    echo "adding: ".$child."<br>";
//                    $found->addChildren( $child );
//                }
//                return $this->setResult($found, $orderinfo, $entity);
//
//                //$entity->setId( $found->getId() );
//                //return $this->setResult($entity, $orderinfo);
//
//            } else {
//                echo "Case 3: object does not exist in DB (new key is eneterd) <br>";
//            }
//
//        }

        $accessions = $entity->getAccession();
        if( count($accessions) > 1 ) {
            throw new \Exception( 'More than one Accession in the Procedure. Number of accession=' . count($accessions) );
        }

        return $this->setResult($entity, $orderinfo);

    }





    public function processEntity_OLD( $entity, $orderinfo ) {

        $em = $this->_em;

        //find accession
        $accessions = $entity->getAccession();

//        ////////////////////// clean acc ////////////////////////
//        //clean accession: for example, user eneterd the same patient with the same acc number => we will have more than one accession in procedure
//        foreach( $accessions as $acc ) {
//            $sameAcc = $this->findSimilarChild($entity,$acc);
//            if( $sameAcc ) {
//                echo "same acc found<br>";
//                //attach all sub-children to found similar child
//                $children = $acc->getChildren();
//                foreach( $children as $child ) {
//                    $sameAcc->addChildren($child);
//                }
//                if( count($entity->getAccession()) > 1 ) {
//                    echo "remove acc=".$acc;
//                    $entity->removeChildren($acc);
//                    //$orderinfo->removeAccession($acc);
//                    $acc->removeOrderinfo($orderinfo);
//                }
//            }
//        }
//        ////////////////////// clean acc ////////////////////////

        if( count($accessions) > 1 ) {
            throw new \Exception( 'More than one Accession in the Procedure. Number of accession=' . count($accessions) );
        }

        //we should have only one Accession in the Procedure, because Procedure-Accession is considered as one object for now
        $accession = $accessions->first();

        //redirect to accession repository (skip procedure, because one procedure is linked to one accession)
        $accessionProcessed = $em->getRepository('OlegOrderformBundle:Accession')->processEntity( $accession, $orderinfo );
        //echo "exit Accession process<br>";

        //process Procedure
        $procedureProcessed = $accessionProcessed->getProcedure();

        if( !$procedureProcessed ) {
            //$procedureProcessed = $em->getRepository('OlegOrderformBundle:Procedure')->createElement(null,$orderinfo->getProvider()->first(),"Procedure","encounter",$entity->getParent(),null,null);
            //$procedureProcessed->addChildren($accessionProcessed);

            //$procedureProcessed->addName($entity->getName());
            $entity->removeChildren($accession);
            $entity->addChildren($accessionProcessed);

            $procedureProcessed = $entity;

            //echo "No procedures <br>";
        }

        //echo "encounter=".$procedureProcessed->getEncounter()->first().", Name=".$procedureProcessed->getName()->first()."<br>";
        //echo "before process:".$entity;

        //process parent procedure processEntity method (setResult method is provided here)
        $procedureProcessed = parent::processEntity( $procedureProcessed, $orderinfo );

        //Exception for procedure: Final Step CopyFields
        $procedureProcessed = $this->processFieldArrays($procedureProcessed,$orderinfo,$entity);

        //echo "after process:".$entity;

        return $procedureProcessed;
    }

    public function setResult_OLD( $procedure, $orderinfo=null, $original=null ) {

        //set status 'valid'
        $procedure->setStatus(self::STATUS_VALID);

        //CopyFields
        $procedure = $this->processFieldArrays($procedure,$orderinfo,$original);

        if( count($procedure->getAccession()) > 1 ) {
            throw new \Exception( 'More than one Accession in the Procedure. Number of accession=' . count($procedure->getAccession()) );
        }

        //link orderinfo with accession
        $accession = $procedure->getAccession()->first();

        //we have to process accession again because the original accession's methods exexutes by the end of orderinfo process
        $accession = $this->processFieldArrays($accession,$orderinfo);
        $em = $this->_em;
        $accession = $em->getRepository('OlegOrderformBundle:Accession')->changeKeytype($accession);

        //add accession and procedure to orderinfo
//        $attached = $this->attachToOrderinfo($accession,$orderinfo);
//        if( $attached > 0 ) {
//            //echo "add procedure ".$attached."<br>";
//            //$this->attachToOrderinfo($procedure,$orderinfo);
//            $orderinfo->addProcedure($procedure);
//        } else {
//            //echo "do not add procedure:".$procedure;
//        }

        //echo "acc children=".count();

//        ////////////////////// clean acc ////////////////////////
//        //clean accession: for example, user entered the same patient with the same acc number => we will have more than one accession in procedure
//        foreach( $procedure->getAccession() as $acc ) {
//            $sameAcc = $this->findSimilarChild($procedure,$acc);
//            if( $sameAcc ) {
//                //attach all sub-children to found similar child
//                $children = $acc->getChildren();
//                foreach( $children as $child ) {
//                    $sameAcc->addChildren($child);
//                }
//                if( count($procedure->getAccession()) > 1 ) {
//                    $procedure->removeChildren($acc);
//                    $orderinfo->removeAccession($acc);
//                }
//            }
//        }
//        ////////////////////// clean acc ////////////////////////

        if( !$procedure->getId() || $procedure->getId() == "" ) {
            //echo "persist Procedure<br>";
            $em->persist($procedure);
        } else {
            //echo "merge Procedure<br>";
            //$em->merge($entity);
        }

        return $procedure;
    }

    //exception for procedure: procedure is linked to a single accession => check if accession is already existed in DB, if existed => don't create procedure, but use existing procedure
    public function findUniqueByKey( $entity ) {

        //echo "findUniqueByKey: Procedure: ".$entity;

        if( count($entity->getChildren()) != 1 ) {
            throw new \Exception( 'This entity must have only one child. Number of children=' . count($entity->getChildren()) );
        }

//        $accession = $entity->getChildren()->first();
//        $class = new \ReflectionClass($accession);
//        $className = $class->getShortName();
//        //echo "findUniqueByKey: Procedure: className=".$className."<br>";

        $em = $this->_em;
        $foundAccession = $em->getRepository('OlegOrderformBundle:Accession')->findUniqueByKey( $entity->getChildren()->first() );    //,"Accession","accession");

        if( $foundAccession ) {
            //echo "This entity alsready exists in DB ".$foundAccession."<br>";
            //get existing procedure
            return $foundAccession->getParent(); //Accession->getProcedure => procedure

        } else {
            return null;
        }
    }

    //replace child if duplicated
    //$parent: patient
    //procedure has only one accession
    public function replaceDuplicateEntities( $parent, $orderinfo ) {
        //echo "Procedure replace duplicates:".$parent;
        return $parent;
    }



    //find similar procedure in patient.
    //However, procedure is identified by accession number
    //$parent: patient
    //$newChild: accession
    //find similar child and return the first one
    //return false if no similar children are found
    public function findSimilarChild($parent,$newChild) {
        //echo "Procedure: find similar Child to: ".$newChild." <br>";

        $children = $parent->getChildren();

        //echo "<br>";
        //echo $newChild;
        //echo "newChild key=".$newChild->obtainValidKeyfield()."<br>";
        if( $newChild->obtainValidKeyfield()."" == "" ) {   //no name is provided, so can't compare => does not exist
            //echo "false: no name <br>";
            return false;
        }

        if( !$children || count($children) == 0 ) { //no children => does not exist
            //echo "false: no children <br>";
            return false;
        }

        foreach( $children as $child ) {
            //echo $child;

            if( count($child->getAccession()) != 1 ) {
                throw new \Exception( 'This entity must have only one child. Number of children=' . count($child->getAccession()) );
            }

            if( $child->getAccession()->first() === $newChild ) {
                //echo "the same child: continue<br>";
                return false;
            }

            if( $this->entityEqualByComplexKey($child->getAccession()->first(), $newChild) ) {
                //echo "MATCH!: ".$child." <br>";
                return $child;
            } else {
                //echo "NO MATCH! <br>";
            }

        }//foreach

        return false;
    }


    //TODO: remove MRN check (check procedure only by Accession number)
    //filter out duplicate virtual (in form, not in DB) procedures from provided patient
    public function removeDuplicateEntities( $patient ) {

        $procedures = $patient->getProcedure();
        //echo "procedure count=".count($procedures)."<br>";
        if( count($procedures) <= 1 ) {
            //echo "only 0 or 1 procedure found=".count($procedures)."<br>";
            //exit();
            return $patient;
        }

        //echo "procedure count1=".count($patient->getProcedure())."<br>";

        $count = 0;
        foreach( $procedures as $procedure ) {

            //echo $procedure;

            //1) check if accession is given
            $accessions = $procedure->getAccession();
            if( $accessions == null || count($accessions) == 0 ) {
                //can't check for duplicate without accession => don't remove this procedure => keep this procedure as unique
                //echo "cant check for duplicate without accession <br>";
                continue;
            }

            //2) check if at least one accession belongs to another (second) procedure, then we can potentially use this first procedure and remove the second one.
            $accession_found = null;
            foreach( $accessions as $accession ) {

                //if accession exists then return procedure for this accession; otherwise, create a new
                if( ($count+1) < count($procedures) ) { //make sure index exists and no need to check the last procedure

                    //if( in_array($accession, $procedures[$count+1]->getAccession() ) ) {
                    foreach( $procedures[$count+1]->getAccession() as $accNext ) {
                        //echo "compare: ".$accession->getAccession() ."?". $accNext->getAccession()."<br>";
                        if( $accession->getAccession() == $accNext->getAccession() ) {
                            $accession_found = $accession;
                            break;
                        }
                    }
                }
            }

            $em = $this->_em;

            if( $accession_found == null || $accession_found->getProcedure() == null ) {
                //don't remove
                //echo "no common accessions found <br>";
                //persist the rest of procedures, because they will be added to DB.
                $em->persist($procedure);
            } else {
                //now check if the next procedure (potentially to be removed) has the same MRN, don't check if MRN = "" => new dummy mrn will be generated
                if( $procedure->getPatient()->getMrn() != null && $procedure->getPatient()->getMrn() != "" ) {
                    if( $procedures[$count+1]->getPatient()->getMrn() == $procedure->getPatient()->getMrn() ) {
                        $patient->removeProcedure( $procedures[$count+1] );
                        //echo "remove procedure=".$procedure[$count+1];
                    } else {
                        $em->persist($procedure);
                    }
                }
            }

            $count++;
        }

        //echo "procedure count2=".count($patient->getprocedure())."<br>";
        //exit();

        return $patient;
    }

}
